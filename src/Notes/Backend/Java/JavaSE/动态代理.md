# 什么是动态代理

动态代理是Java中的一种设计模式，它允许在运行时动态地创建一个实现了一组接口的代理类。动态代理可以在不修改原始类代码的情况下，为原始类添加额外的功能，例如日志记录、事务管理、安全检查等。

# 动态代理的实现方式

Java中实现动态代理主要有两种方式：

1. **基于接口的动态代理**：使用`java.lang.reflect.Proxy`类和`java.lang.reflect.InvocationHandler`接口实现。
2. **基于类的动态代理**：使用第三方库如CGLIB实现。

## 基于接口的动态代理

### 核心类和接口

- **Proxy类**：提供了创建动态代理类和实例的静态方法。
- **InvocationHandler接口**：定义了处理代理实例上方法调用的方法。

### 实现步骤

1. **定义接口**：定义一个或多个接口，作为代理类和目标类的共同接口。
2. **实现目标类**：实现上述接口的类，包含具体的业务逻辑。
3. **实现InvocationHandler**：实现`InvocationHandler`接口，处理代理实例上的方法调用。
4. **创建代理实例**：使用`Proxy.newProxyInstance()`方法创建代理实例。

### 示例

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 1. 定义接口
interface UserService {
    void addUser(String name);
    void deleteUser(String name);
}

// 2. 实现目标类
class UserServiceImpl implements UserService {
    @Override
    public void addUser(String name) {
        System.out.println("添加用户：" + name);
    }
    
    @Override
    public void deleteUser(String name) {
        System.out.println("删除用户：" + name);
    }
}

// 3. 实现InvocationHandler
class UserServiceProxy implements InvocationHandler {
    private Object target; // 目标对象
    
    public UserServiceProxy(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 前置处理
        System.out.println("调用方法前：" + method.getName());
        
        // 调用目标方法
        Object result = method.invoke(target, args);
        
        // 后置处理
        System.out.println("调用方法后：" + method.getName());
        
        return result;
    }
}

// 测试类
public class DynamicProxyExample {
    public static void main(String[] args) {
        // 创建目标对象
        UserService userService = new UserServiceImpl();
        
        // 创建InvocationHandler实例
        UserServiceProxy proxyHandler = new UserServiceProxy(userService);
        
        // 4. 创建代理实例
        UserService proxy = (UserService) Proxy.newProxyInstance(
            userService.getClass().getClassLoader(),
            userService.getClass().getInterfaces(),
            proxyHandler
        );
        
        // 调用代理方法
        proxy.addUser("Tom");
        System.out.println("-----------------");
        proxy.deleteUser("Jerry");
    }
}
```

### 运行结果

```
调用方法前：addUser
添加用户：Tom
调用方法后：addUser
-----------------
调用方法前：deleteUser
删除用户：Jerry
调用方法后：deleteUser
```

## 基于类的动态代理（CGLIB）

### 什么是CGLIB

CGLIB（Code Generation Library）是一个第三方库，它可以在运行时动态地生成类的子类，从而实现基于类的动态代理。与基于接口的动态代理不同，CGLIB不需要目标类实现接口。

### 核心类

- **Enhancer**：CGLIB的核心类，用于生成代理类。
- **MethodInterceptor**：定义了拦截方法调用的接口。

### 实现步骤

1. **添加CGLIB依赖**：在项目中添加CGLIB库的依赖。
2. **实现目标类**：不需要实现接口的普通类。
3. **实现MethodInterceptor**：实现`MethodInterceptor`接口，处理代理实例上的方法调用。
4. **创建代理实例**：使用`Enhancer`类创建代理实例。

### 示例

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;

// 1. 实现目标类（不需要实现接口）
class UserService {
    public void addUser(String name) {
        System.out.println("添加用户：" + name);
    }
    
    public void deleteUser(String name) {
        System.out.println("删除用户：" + name);
    }
}

// 2. 实现MethodInterceptor
class UserServiceInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 前置处理
        System.out.println("调用方法前：" + method.getName());
        
        // 调用目标方法
        Object result = proxy.invokeSuper(obj, args);
        
        // 后置处理
        System.out.println("调用方法后：" + method.getName());
        
        return result;
    }
}

// 测试类
public class CGLIBProxyExample {
    public static void main(String[] args) {
        // 创建Enhancer实例
        Enhancer enhancer = new Enhancer();
        
        // 设置目标类
        enhancer.setSuperclass(UserService.class);
        
        // 设置回调
        enhancer.setCallback(new UserServiceInterceptor());
        
        // 3. 创建代理实例
        UserService proxy = (UserService) enhancer.create();
        
        // 调用代理方法
        proxy.addUser("Tom");
        System.out.println("-----------------");
        proxy.deleteUser("Jerry");
    }
}
```

### 运行结果

```
调用方法前：addUser
添加用户：Tom
调用方法后：addUser
-----------------
调用方法前：deleteUser
删除用户：Jerry
调用方法后：deleteUser
```

# 动态代理的应用场景

## 1. 日志记录

使用动态代理可以在方法调用前后自动记录日志，无需修改原始方法的代码。

### 示例

```java
public class LoggingProxy implements InvocationHandler {
    private Object target;
    
    public LoggingProxy(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 记录方法调用开始
        System.out.println("[LOG] 方法 " + method.getName() + " 开始执行");
        
        // 调用目标方法
        Object result = method.invoke(target, args);
        
        // 记录方法调用结束
        System.out.println("[LOG] 方法 " + method.getName() + " 执行结束");
        
        return result;
    }
}
```

## 2. 事务管理

使用动态代理可以在方法调用前后自动管理事务，例如开始事务、提交事务或回滚事务。

### 示例

```java
public class TransactionProxy implements InvocationHandler {
    private Object target;
    
    public TransactionProxy(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Object result = null;
        try {
            // 开始事务
            System.out.println("[TRANSACTION] 开始事务");
            
            // 调用目标方法
            result = method.invoke(target, args);
            
            // 提交事务
            System.out.println("[TRANSACTION] 提交事务");
        } catch (Exception e) {
            // 回滚事务
            System.out.println("[TRANSACTION] 回滚事务");
            throw e;
        }
        return result;
    }
}
```

## 3. 安全检查

使用动态代理可以在方法调用前进行安全检查，例如验证用户权限。

### 示例

```java
public class SecurityProxy implements InvocationHandler {
    private Object target;
    private String userRole;
    
    public SecurityProxy(Object target, String userRole) {
        this.target = target;
        this.userRole = userRole;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 检查方法是否需要权限
        if (method.isAnnotationPresent(Secured.class)) {
            Secured secured = method.getAnnotation(Secured.class);
            String requiredRole = secured.role();
            
            // 验证用户权限
            if (!userRole.equals(requiredRole)) {
                throw new SecurityException("权限不足，无法执行此操作");
            }
        }
        
        // 调用目标方法
        return method.invoke(target, args);
    }
}

// 自定义注解
@interface Secured {
    String role();
}

// 使用注解标记需要权限的方法
class AdminService {
    @Secured(role = "admin")
    public void deleteUser(String name) {
        System.out.println("删除用户：" + name);
    }
}
```

## 4. 缓存

使用动态代理可以在方法调用前检查缓存，如果缓存中存在结果则直接返回，否则调用目标方法并将结果存入缓存。

### 示例

```java
import java.util.HashMap;
import java.util.Map;

public class CachingProxy implements InvocationHandler {
    private Object target;
    private Map<String, Object> cache = new HashMap<>();
    
    public CachingProxy(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 生成缓存键
        StringBuilder keyBuilder = new StringBuilder(method.getName());
        if (args != null) {
            for (Object arg : args) {
                keyBuilder.append("_");
                keyBuilder.append(arg);
            }
        }
        String cacheKey = keyBuilder.toString();
        
        // 检查缓存
        if (cache.containsKey(cacheKey)) {
            System.out.println("[CACHE] 从缓存中获取结果：" + cacheKey);
            return cache.get(cacheKey);
        }
        
        // 调用目标方法
        Object result = method.invoke(target, args);
        
        // 将结果存入缓存
        cache.put(cacheKey, result);
        System.out.println("[CACHE] 将结果存入缓存：" + cacheKey);
        
        return result;
    }
}
```

## 5. 远程调用

使用动态代理可以实现远程方法调用（RPC），例如通过网络调用远程服务器上的方法。

### 示例

```java
public class RemoteProxy implements InvocationHandler {
    private String serverAddress;
    
    public RemoteProxy(String serverAddress) {
        this.serverAddress = serverAddress;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 构建远程调用请求
        RemoteRequest request = new RemoteRequest();
        request.setMethodName(method.getName());
        request.setArguments(args);
        request.setReturnType(method.getReturnType());
        
        // 发送请求到远程服务器
        System.out.println("[REMOTE] 发送请求到服务器：" + serverAddress);
        
        // 模拟远程调用
        RemoteResponse response = simulateRemoteCall(request);
        
        // 返回远程调用结果
        return response.getResult();
    }
    
    private RemoteResponse simulateRemoteCall(RemoteRequest request) {
        // 模拟远程服务器处理请求
        System.out.println("[REMOTE] 服务器处理请求：" + request.getMethodName());
        
        // 构建响应
        RemoteResponse response = new RemoteResponse();
        response.setResult("远程调用结果");
        
        return response;
    }
}

// 远程请求类
class RemoteRequest {
    private String methodName;
    private Object[] arguments;
    private Class<?> returnType;
    
    // getters and setters
    public String getMethodName() { return methodName; }
    public void setMethodName(String methodName) { this.methodName = methodName; }
    public Object[] getArguments() { return arguments; }
    public void setArguments(Object[] arguments) { this.arguments = arguments; }
    public Class<?> getReturnType() { return returnType; }
    public void setReturnType(Class<?> returnType) { this.returnType = returnType; }
}

// 远程响应类
class RemoteResponse {
    private Object result;
    
    // getters and setters
    public Object getResult() { return result; }
    public void setResult(Object result) { this.result = result; }
}
```

# 两种动态代理方式的对比

| 特性 | 基于接口的动态代理（Proxy） | 基于类的动态代理（CGLIB） |
|------|---------------------------|------------------------|
| 实现方式 | 使用Java反射API | 使用字节码生成技术 |
| 目标类要求 | 必须实现接口 | 不需要实现接口 |
| 性能 | 相对较低 | 相对较高 |
| 适用场景 | 目标类实现了接口 | 目标类没有实现接口 |
| 依赖 | JDK内置，无需额外依赖 | 需要引入CGLIB库 |

# 示例代码

## 基于接口的动态代理完整示例

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 定义接口
interface Calculator {
    int add(int a, int b);
    int subtract(int a, int b);
    int multiply(int a, int b);
    int divide(int a, int b);
}

// 实现目标类
class CalculatorImpl implements Calculator {
    @Override
    public int add(int a, int b) {
        return a + b;
    }
    
    @Override
    public int subtract(int a, int b) {
        return a - b;
    }
    
    @Override
    public int multiply(int a, int b) {
        return a * b;
    }
    
    @Override
    public int divide(int a, int b) {
        if (b == 0) {
            throw new ArithmeticException("除数不能为零");
        }
        return a / b;
    }
}

// 实现InvocationHandler
class CalculatorProxy implements InvocationHandler {
    private Object target;
    
    public CalculatorProxy(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 前置处理
        System.out.println("[LOG] 方法 " + method.getName() + " 开始执行，参数：" + args[0] + ", " + args[1]);
        
        Object result = null;
        try {
            // 调用目标方法
            result = method.invoke(target, args);
            
            // 后置处理
            System.out.println("[LOG] 方法 " + method.getName() + " 执行成功，结果：" + result);
        } catch (Exception e) {
            // 异常处理
            System.out.println("[LOG] 方法 " + method.getName() + " 执行异常：" + e.getMessage());
            throw e;
        }
        
        return result;
    }
}

// 测试类
public class ProxyExample {
    public static void main(String[] args) {
        // 创建目标对象
        Calculator calculator = new CalculatorImpl();
        
        // 创建InvocationHandler实例
        CalculatorProxy proxyHandler = new CalculatorProxy(calculator);
        
        // 创建代理实例
        Calculator proxy = (Calculator) Proxy.newProxyInstance(
            calculator.getClass().getClassLoader(),
            calculator.getClass().getInterfaces(),
            proxyHandler
        );
        
        // 调用代理方法
        System.out.println("10 + 5 = " + proxy.add(10, 5));
        System.out.println("10 - 5 = " + proxy.subtract(10, 5));
        System.out.println("10 * 5 = " + proxy.multiply(10, 5));
        System.out.println("10 / 5 = " + proxy.divide(10, 5));
        
        try {
            System.out.println("10 / 0 = " + proxy.divide(10, 0));
        } catch (Exception e) {
            System.out.println("捕获异常：" + e.getMessage());
        }
    }
}
```

## 基于类的动态代理（CGLIB）完整示例

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;

// 实现目标类（不需要实现接口）
class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
    
    public int subtract(int a, int b) {
        return a - b;
    }
    
    public int multiply(int a, int b) {
        return a * b;
    }
    
    public int divide(int a, int b) {
        if (b == 0) {
            throw new ArithmeticException("除数不能为零");
        }
        return a / b;
    }
}

// 实现MethodInterceptor
class CalculatorInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        // 前置处理
        System.out.println("[LOG] 方法 " + method.getName() + " 开始执行，参数：" + args[0] + ", " + args[1]);
        
        Object result = null;
        try {
            // 调用目标方法
            result = proxy.invokeSuper(obj, args);
            
            // 后置处理
            System.out.println("[LOG] 方法 " + method.getName() + " 执行成功，结果：" + result);
        } catch (Exception e) {
            // 异常处理
            System.out.println("[LOG] 方法 " + method.getName() + " 执行异常：" + e.getMessage());
            throw e;
        }
        
        return result;
    }
}

// 测试类
public class CGLIBExample {
    public static void main(String[] args) {
        // 创建Enhancer实例
        Enhancer enhancer = new Enhancer();
        
        // 设置目标类
        enhancer.setSuperclass(Calculator.class);
        
        // 设置回调
        enhancer.setCallback(new CalculatorInterceptor());
        
        // 创建代理实例
        Calculator proxy = (Calculator) enhancer.create();
        
        // 调用代理方法
        System.out.println("10 + 5 = " + proxy.add(10, 5));
        System.out.println("10 - 5 = " + proxy.subtract(10, 5));
        System.out.println("10 * 5 = " + proxy.multiply(10, 5));
        System.out.println("10 / 5 = " + proxy.divide(10, 5));
        
        try {
            System.out.println("10 / 0 = " + proxy.divide(10, 0));
        } catch (Exception e) {
            System.out.println("捕获异常：" + e.getMessage());
        }
    }
}
```

# 总结

动态代理是Java中的一种重要设计模式，它允许在运行时动态地创建代理类，为原始类添加额外的功能。Java中实现动态代理主要有两种方式：基于接口的动态代理（使用`Proxy`类和`InvocationHandler`接口）和基于类的动态代理（使用CGLIB库）。

动态代理的应用场景非常广泛，包括日志记录、事务管理、安全检查、缓存和远程调用等。通过使用动态代理，我们可以在不修改原始类代码的情况下，为原始类添加额外的功能，提高代码的可维护性和可扩展性。

在选择动态代理的实现方式时，需要考虑目标类是否实现了接口：如果目标类实现了接口，可以使用基于接口的动态代理；如果目标类没有实现接口，则需要使用基于类的动态代理（CGLIB）。

动态代理是Java中实现AOP（面向切面编程）的重要手段之一，掌握动态代理的使用方法对于理解和开发Java应用程序都非常重要。