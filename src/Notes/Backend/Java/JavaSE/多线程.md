# 什么是多线程

多线程是指在一个程序中同时运行多个线程，每个线程执行不同的任务。多线程可以提高程序的执行效率，充分利用 CPU 资源，特别是在多核处理器的系统中。

# 线程与进程的区别

## 进程

进程是程序的一次执行过程，是操作系统进行资源分配和调度的基本单位。每个进程都有自己独立的内存空间和系统资源。

## 线程

线程是进程中的一个执行单元，是 CPU 调度和执行的基本单位。一个进程可以包含多个线程，这些线程共享进程的内存空间和系统资源。

## 线程与进程的对比

| 特性     | 进程                                           | 线程                                             |
| -------- | ---------------------------------------------- | ------------------------------------------------ |
| 资源分配 | 每个进程有独立的内存空间和系统资源             | 多个线程共享进程的内存空间和系统资源             |
| 切换开销 | 进程切换开销较大                               | 线程切换开销较小                                 |
| 通信方式 | 进程间通信复杂（如管道、消息队列、共享内存等） | 线程间通信简单（如共享变量、wait/notify 机制等） |
| 安全性   | 进程间相互独立，安全性高                       | 线程间共享资源，安全性较低，需要同步机制         |

# 线程的创建方式

Java 中创建线程有三种方式：

## 1. 继承 Thread 类

通过继承 Thread 类并重写 run()方法来创建线程。

### 示例

```java
public class ThreadExample extends Thread {
    @Override
    public void run() {
        System.out.println("线程执行：" + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        // 创建线程实例
        ThreadExample thread = new ThreadExample();
        // 启动线程
        thread.start();

        System.out.println("主线程执行：" + Thread.currentThread().getName());
    }
}
```

## 2. 实现 Runnable 接口

通过实现 Runnable 接口并实现 run()方法来创建线程。

### 示例

```java
public class RunnableExample implements Runnable {
    @Override
    public void run() {
        System.out.println("线程执行：" + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        // 创建Runnable实例
        RunnableExample runnable = new RunnableExample();
        // 创建Thread实例并传入Runnable
        Thread thread = new Thread(runnable);
        // 启动线程
        thread.start();

        System.out.println("主线程执行：" + Thread.currentThread().getName());
    }
}
```

## 3. 实现 Callable 接口

通过实现 Callable 接口并实现 call()方法来创建线程，这种方式可以返回执行结果。

### 示例

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableExample implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        System.out.println("线程执行：" + Thread.currentThread().getName());
        return 42; // 返回执行结果
    }

    public static void main(String[] args) {
        // 创建Callable实例
        CallableExample callable = new CallableExample();
        // 创建FutureTask实例并传入Callable
        FutureTask<Integer> futureTask = new FutureTask<>(callable);
        // 创建Thread实例并传入FutureTask
        Thread thread = new Thread(futureTask);
        // 启动线程
        thread.start();

        System.out.println("主线程执行：" + Thread.currentThread().getName());

        try {
            // 获取线程执行结果
            Integer result = futureTask.get();
            System.out.println("线程执行结果：" + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

# 线程的生命周期

线程的生命周期包含五个状态：

## 1. 新建状态（New）

当创建 Thread 实例时，线程处于新建状态，此时线程还没有开始执行。

## 2. 就绪状态（Runnable）

当调用线程的 start()方法后，线程进入就绪状态，此时线程等待 CPU 的调度。

## 3. 运行状态（Running）

当 CPU 开始执行线程的 run()方法时，线程进入运行状态。

## 4. 阻塞状态（Blocked）

当线程遇到以下情况时，会进入阻塞状态：

- 线程调用 sleep()方法
- 线程调用 wait()方法
- 线程等待 I/O 操作完成
- 线程等待获取锁

当阻塞原因消除后，线程会重新进入就绪状态，等待 CPU 的调度。

## 5. 死亡状态（Terminated）

当线程的 run()方法执行完毕，或者线程被强制终止（如调用 stop()方法），线程进入死亡状态。

# 线程的常用方法

## 1. start()

启动线程，使线程进入就绪状态，等待 CPU 的调度。

## 2. run()

线程的执行方法，包含线程的执行逻辑。

## 3. sleep(long millis)

使线程休眠指定的毫秒数，线程进入阻塞状态。

## 4. wait()

使线程进入等待状态，直到其他线程调用 notify()或 notifyAll()方法唤醒它。

## 5. notify()

唤醒一个在该对象上等待的线程。

## 6. notifyAll()

唤醒所有在该对象上等待的线程。

## 7. join()

等待该线程执行完毕，再继续执行其他线程。

## 8. interrupt()

中断线程的执行。

## 9. isInterrupted()

判断线程是否被中断。

## 10. currentThread()

获取当前执行的线程。

# 线程同步

线程同步是指多个线程在访问共享资源时，按照一定的顺序执行，避免出现数据不一致的情况。

## 为什么需要线程同步

当多个线程同时访问共享资源时，可能会导致数据不一致的问题，例如：

- 多个线程同时修改同一个变量
- 多个线程同时操作同一个集合
- 多个线程同时访问同一个文件

## 线程同步的实现方式

### 1. synchronized 关键字

`synchronized`关键字可以修饰方法或代码块，保证同一时刻只有一个线程可以执行被修饰的代码。

#### 修饰方法

```java
public synchronized void synchronizedMethod() {
    // 同步代码
}
```

#### 修饰代码块

```java
public void method() {
    synchronized (this) {
        // 同步代码
    }
}
```

#### 示例

```java
public class SynchronizedExample {
    private int count = 0;

    // 同步方法
    public synchronized void increment() {
        count++;
    }

    // 同步代码块
    public void decrement() {
        synchronized (this) {
            count--;
        }
    }

    public int getCount() {
        return count;
    }

    public static void main(String[] args) {
        SynchronizedExample example = new SynchronizedExample();

        // 创建并启动多个线程
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                example.increment();
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                example.increment();
            }
        });

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("最终计数：" + example.getCount());
    }
}
```

### 2. ReentrantLock

`ReentrantLock`是 Java 5 引入的一种可重入锁，它提供了比`synchronized`更灵活的锁定机制。

#### 示例

```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {
        lock.lock(); // 获取锁
        try {
            count++;
        } finally {
            lock.unlock(); // 释放锁
        }
    }

    public int getCount() {
        return count;
    }

    public static void main(String[] args) {
        ReentrantLockExample example = new ReentrantLockExample();

        // 创建并启动多个线程
        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                example.increment();
            }
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                example.increment();
            }
        });

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("最终计数：" + example.getCount());
    }
}
```

### 3. volatile 关键字

`volatile`关键字用于修饰变量，保证变量的可见性和有序性，但不保证原子性。

#### 示例

```java
public class VolatileExample {
    private volatile boolean flag = false;

    public void setFlag(boolean flag) {
        this.flag = flag;
    }

    public boolean getFlag() {
        return flag;
    }

    public static void main(String[] args) {
        VolatileExample example = new VolatileExample();

        // 创建并启动线程1
        Thread thread1 = new Thread(() -> {
            while (!example.getFlag()) {
                // 循环等待
            }
            System.out.println("线程1：flag变为true，退出循环");
        });

        thread1.start();

        // 主线程休眠1秒
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 主线程设置flag为true
        example.setFlag(true);
        System.out.println("主线程：设置flag为true");
    }
}
```

# 线程池

线程池是一种线程管理机制，它可以预先创建一定数量的线程，当有任务需要执行时，从线程池中获取线程，执行完毕后线程不会被销毁，而是返回线程池等待下一个任务。

## 线程池的优点

1. **提高线程的利用率**：线程池中的线程可以重复使用，避免了线程的创建和销毁带来的开销。

2. **控制线程的数量**：线程池可以控制线程的数量，避免线程过多导致系统资源耗尽。

3. **提高响应速度**：当有任务需要执行时，从线程池中获取线程，不需要等待线程的创建。

4. **便于管理**：线程池可以对线程进行统一的管理，例如监控线程的状态、设置线程的优先级等。

## 线程池的创建方式

Java 中创建线程池的方式有多种，常用的有以下几种：

### 1. Executors 工厂类

`Executors`类提供了创建线程池的静态方法：

- `newFixedThreadPool(int nThreads)`：创建固定大小的线程池
- `newCachedThreadPool()`：创建可缓存的线程池
- `newSingleThreadExecutor()`：创建单线程的线程池
- `newScheduledThreadPool(int corePoolSize)`：创建定时任务的线程池

### 2. ThreadPoolExecutor 类

`ThreadPoolExecutor`是线程池的核心实现类，可以通过它来自定义线程池的参数。

### 示例

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建固定大小的线程池
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        // 提交任务到线程池
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executorService.submit(() -> {
                System.out.println("任务" + taskId + "由线程" + Thread.currentThread().getName() + "执行");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }

        // 关闭线程池
        executorService.shutdown();
    }
}
```

# 线程安全的集合

Java 中提供了一些线程安全的集合类，这些集合类可以在多线程环境中安全使用：

## 1. ConcurrentHashMap

`ConcurrentHashMap`是`HashMap`的线程安全版本，它使用分段锁的机制，提高了并发性能。

## 2. CopyOnWriteArrayList

`CopyOnWriteArrayList`是`ArrayList`的线程安全版本，它在修改操作时会创建一个新的数组副本，避免了读写冲突。

## 3. CopyOnWriteArraySet

`CopyOnWriteArraySet`是`HashSet`的线程安全版本，它基于`CopyOnWriteArrayList`实现。

## 4. ConcurrentLinkedQueue

`ConcurrentLinkedQueue`是一个线程安全的无界队列，它使用 CAS 操作实现线程安全。

## 5. BlockingQueue

`BlockingQueue`是一个支持阻塞操作的队列，它提供了以下方法：

- `put(E e)`：将元素放入队列，如果队列已满，则阻塞直到队列有空间。
- `take()`：从队列中取出元素，如果队列为空，则阻塞直到队列有元素。

# 示例代码

## 多线程的完整示例

```java
public class MultiThreadExample {
    public static void main(String[] args) {
        // 创建并启动线程1
        Thread thread1 = new Thread(new MyRunnable("线程1"));
        thread1.start();

        // 创建并启动线程2
        Thread thread2 = new Thread(new MyRunnable("线程2"));
        thread2.start();

        // 主线程执行
        for (int i = 0; i < 5; i++) {
            System.out.println("主线程执行：" + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("主线程执行完毕");
    }
}

class MyRunnable implements Runnable {
    private String name;

    public MyRunnable(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(name + "执行：" + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(name + "执行完毕");
    }
}
```

## 线程同步的完整示例

```java
public class ThreadSyncExample {
    public static void main(String[] args) {
        // 创建共享资源
        SharedResource sharedResource = new SharedResource();

        // 创建并启动多个线程
        Thread thread1 = new Thread(new Worker(sharedResource, "线程1"));
        Thread thread2 = new Thread(new Worker(sharedResource, "线程2"));
        Thread thread3 = new Thread(new Worker(sharedResource, "线程3"));

        thread1.start();
        thread2.start();
        thread3.start();
    }
}

class SharedResource {
    private int count = 0;

    // 同步方法
    public synchronized void increment() {
        count++;
        System.out.println(Thread.currentThread().getName() + "：count = " + count);
    }
}

class Worker implements Runnable {
    private SharedResource sharedResource;
    private String name;

    public Worker(SharedResource sharedResource, String name) {
        this.sharedResource = sharedResource;
        this.name = name;
    }

    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            sharedResource.increment();
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

# 总结

多线程是指在一个程序中同时运行多个线程，每个线程执行不同的任务。多线程可以提高程序的执行效率，充分利用 CPU 资源。

Java 中创建线程有三种方式：继承 Thread 类、实现 Runnable 接口和实现 Callable 接口。线程的生命周期包含五个状态：新建状态、就绪状态、运行状态、阻塞状态和死亡状态。

线程同步是指多个线程在访问共享资源时，按照一定的顺序执行，避免出现数据不一致的情况。Java 中实现线程同步的方式有：synchronized 关键字、ReentrantLock 和 volatile 关键字。

线程池是一种线程管理机制，它可以预先创建一定数量的线程，当有任务需要执行时，从线程池中获取线程，执行完毕后线程不会被销毁，而是返回线程池等待下一个任务。

合理使用多线程可以提高程序的执行效率，但也需要注意线程安全的问题，避免出现数据不一致的情况。
