# 什么是方法引用

方法引用是Java 8引入的一种特性，它是Lambda表达式的一种简化形式，用于直接引用已有的方法。方法引用可以使代码更加简洁易读，特别是当Lambda表达式只是调用一个已有的方法时。

# 方法引用的语法

方法引用的基本语法如下：

```java
// 静态方法引用
ClassName::staticMethodName

// 实例方法引用
instance::instanceMethodName

// 类的实例方法引用
ClassName::instanceMethodName

// 构造方法引用
ClassName::new
```

# 方法引用的类型

## 1. 静态方法引用

静态方法引用用于引用类的静态方法。

### 语法

```java
ClassName::staticMethodName
```

### 示例

```java
// 静态方法引用示例
Function<Integer, String> stringConverter = String::valueOf;
String result = stringConverter.apply(123);
System.out.println(result); // 输出：123

// 等价的Lambda表达式
Function<Integer, String> stringConverterLambda = (i) -> String.valueOf(i);
```

## 2. 实例方法引用

实例方法引用用于引用特定对象的实例方法。

### 语法

```java
instance::instanceMethodName
```

### 示例

```java
// 实例方法引用示例
String str = "Hello";
Supplier<Integer> lengthSupplier = str::length;
int length = lengthSupplier.get();
System.out.println(length); // 输出：5

// 等价的Lambda表达式
Supplier<Integer> lengthSupplierLambda = () -> str.length();
```

## 3. 类的实例方法引用

类的实例方法引用用于引用类的任意实例的实例方法。

### 语法

```java
ClassName::instanceMethodName
```

### 示例

```java
// 类的实例方法引用示例
Function<String, Integer> lengthFunction = String::length;
int length = lengthFunction.apply("Hello");
System.out.println(length); // 输出：5

// 等价的Lambda表达式
Function<String, Integer> lengthFunctionLambda = (s) -> s.length();

// 另一个示例：比较两个字符串
BiFunction<String, String, Integer> compareFunction = String::compareTo;
int result = compareFunction.apply("a", "b");
System.out.println(result); // 输出：-1

// 等价的Lambda表达式
BiFunction<String, String, Integer> compareFunctionLambda = (s1, s2) -> s1.compareTo(s2);
```

## 4. 构造方法引用

构造方法引用用于引用类的构造方法。

### 语法

```java
ClassName::new
```

### 示例

```java
// 构造方法引用示例
Supplier<String> stringSupplier = String::new;
String emptyString = stringSupplier.get();
System.out.println(emptyString); // 输出：空字符串

// 等价的Lambda表达式
Supplier<String> stringSupplierLambda = () -> new String();

// 带参数的构造方法引用
Function<String, String> stringFunction = String::new;
String helloString = stringFunction.apply("Hello");
System.out.println(helloString); // 输出：Hello

// 等价的Lambda表达式
Function<String, String> stringFunctionLambda = (s) -> new String(s);
```

# 方法引用的使用场景

方法引用主要用于以下场景：

1. **函数式接口**：实现函数式接口的抽象方法，当抽象方法的实现只是调用一个已有的方法时
2. **集合操作**：使用Stream API进行集合操作，如map、filter、forEach等
3. **方法参数**：作为方法参数传递给需要函数式接口的方法

# 方法引用与Lambda表达式的比较

| 特性 | 方法引用 | Lambda表达式 |
|------|---------|------------|
| 语法 | 更简洁，直接引用已有方法 | 相对冗长，需要显式写出方法调用 |
| 可读性 | 更易读，直接看出调用的是哪个方法 | 相对不易读，需要理解Lambda表达式的逻辑 |
| 适用场景 | 当Lambda表达式只是调用一个已有方法时 | 当需要执行更复杂的逻辑时 |

# 方法引用的注意事项

1. **方法签名匹配**：方法引用的方法签名必须与函数式接口的抽象方法签名匹配
2. **参数传递**：对于类的实例方法引用，第一个参数会成为方法的调用者
3. **构造方法引用**：构造方法引用的参数列表必须与函数式接口的抽象方法参数列表匹配
4. **异常处理**：方法引用中调用的方法如果抛出异常，需要确保函数式接口的方法声明了该异常

# 示例代码

## 方法引用的完整示例

```java
import java.util.Arrays;
import java.util.List;
import java.util.function.*;
import java.util.stream.Collectors;

public class MethodReferenceExample {
    public static void main(String[] args) {
        // 示例1：静态方法引用
        System.out.println("=== 示例1：静态方法引用 ===");
        
        // 静态方法引用
        Function<Integer, String> stringConverter = String::valueOf;
        System.out.println("Converted value: " + stringConverter.apply(123));
        
        // 静态方法引用（自定义静态方法）
        Function<Integer, Integer> squareFunction = MathUtils::square;
        System.out.println("Square of 5: " + squareFunction.apply(5));
        
        // 示例2：实例方法引用
        System.out.println("\n=== 示例2：实例方法引用 ===");
        
        // 实例方法引用
        String str = "Hello, Method Reference!";
        Supplier<Integer> lengthSupplier = str::length;
        System.out.println("String length: " + lengthSupplier.get());
        
        // 实例方法引用（自定义实例方法）
        Person person = new Person("Alice", 30);
        Supplier<String> nameSupplier = person::getName;
        System.out.println("Person name: " + nameSupplier.get());
        
        // 示例3：类的实例方法引用
        System.out.println("\n=== 示例3：类的实例方法引用 ===");
        
        // 类的实例方法引用
        Function<String, Integer> lengthFunction = String::length;
        System.out.println("Length of \"Java\": " + lengthFunction.apply("Java"));
        
        // 类的实例方法引用（比较两个字符串）
        BiFunction<String, String, Integer> compareFunction = String::compareTo;
        System.out.println("Comparison result: " + compareFunction.apply("a", "b"));
        
        // 类的实例方法引用（字符串拼接）
        BiFunction<String, String, String> concatFunction = String::concat;
        System.out.println("Concatenated string: " + concatFunction.apply("Hello", " World"));
        
        // 示例4：构造方法引用
        System.out.println("\n=== 示例4：构造方法引用 ===");
        
        // 无参构造方法引用
        Supplier<Person> personSupplier = Person::new;
        Person newPerson = personSupplier.get();
        System.out.println("New person: " + newPerson.getName() + ", " + newPerson.getAge());
        
        // 带参构造方法引用
        BiFunction<String, Integer, Person> personCreator = Person::new;
        Person alice = personCreator.apply("Alice", 25);
        System.out.println("Created person: " + alice.getName() + ", " + alice.getAge());
        
        // 示例5：方法引用在集合操作中的使用
        System.out.println("\n=== 示例5：方法引用在集合操作中的使用 ===");
        
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        
        // 使用方法引用进行遍历
        System.out.println("Names:");
        names.forEach(System.out::println);
        
        // 使用方法引用进行映射
        List<Integer> nameLengths = names.stream()
            .map(String::length)
            .collect(Collectors.toList());
        System.out.println("Name lengths: " + nameLengths);
        
        // 使用方法引用进行过滤
        List<String> longNames = names.stream()
            .filter(s -> s.length() > 4)
            .collect(Collectors.toList());
        System.out.println("Names longer than 4 characters: " + longNames);
        
        // 示例6：方法引用与函数式接口
        System.out.println("\n=== 示例6：方法引用与函数式接口 ===");
        
        // 使用方法引用实现Comparator接口
        List<String> sortedNames = names.stream()
            .sorted(String::compareTo)
            .collect(Collectors.toList());
        System.out.println("Sorted names: " + sortedNames);
        
        // 使用方法引用实现Predicate接口
        List<String> namesStartingWithA = names.stream()
            .filter(s -> s.startsWith("A"))
            .collect(Collectors.toList());
        System.out.println("Names starting with 'A': " + namesStartingWithA);
    }
}

// 工具类
class MathUtils {
    public static int square(int number) {
        return number * number;
    }
}

// 实体类
class Person {
    private String name;
    private int age;
    
    // 无参构造方法
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }
    
    // 带参构造方法
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
}
```

# 方法引用与Lambda表达式的转换

方法引用可以看作是Lambda表达式的一种简化形式，以下是一些常见的转换示例：

## 1. 静态方法引用

```java
// Lambda表达式
(a, b) -> ClassName.staticMethod(a, b)

// 等价的方法引用
ClassName::staticMethod
```

## 2. 实例方法引用

```java
// Lambda表达式
() -> instance.method()

// 等价的方法引用
instance::method
```

## 3. 类的实例方法引用

```java
// Lambda表达式
(a, b) -> a.method(b)

// 等价的方法引用
ClassName::method
```

## 4. 构造方法引用

```java
// Lambda表达式
(a, b) -> new ClassName(a, b)

// 等价的方法引用
ClassName::new
```

# 方法引用的优点

1. **代码简洁**：方法引用比Lambda表达式更加简洁，特别是当只是调用一个已有方法时
2. **可读性高**：方法引用直接显示了调用的是哪个方法，提高了代码的可读性
3. **减少错误**：方法引用减少了手动编写Lambda表达式的机会，从而减少了潜在的错误
4. **函数式编程**：方法引用支持函数式编程风格，使代码更加模块化和可重用

# 总结

方法引用是Java 8引入的一种特性，它是Lambda表达式的一种简化形式，用于直接引用已有的方法。方法引用有四种类型：静态方法引用、实例方法引用、类的实例方法引用和构造方法引用。

方法引用的语法简洁明了，使用`::`运算符来引用方法。方法引用可以使代码更加简洁易读，特别是当Lambda表达式只是调用一个已有方法时。

方法引用主要用于实现函数式接口的抽象方法，特别适合于集合操作、方法参数传递等场景。合理使用方法引用可以使代码更加清晰、简洁，提高代码的可读性和可维护性。